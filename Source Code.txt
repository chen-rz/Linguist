1.0010 + 2.86E-12 -2.3+2.45i+1+21+ 2.54e99 -1523l+0x83Ul
1.2+3.4i+4.56+7.823e
1.2 + 0XFG
"This is a demo!"
#include <iostream>
#include <algorithm>
using namespace std;
int a = 2..3;
float 2bcd =  3.23;
inline int desc_cmp(int a,int b) {
	return       a>b;
}

from math import exp
from random import shuffle
<!-- import numpy as npy -->
import matplotlib.pyplot as ppl


def sigmoid(arg):
    return 1 / (1 + exp(-arg))


# 读取数据文件
xSrc = []
file = open("ex4x.dat")
line = file.readline()
while line:
    xSrc.append([npy.double(line.split()[0]), npy.double(line.split()[1])])
    line = file.readline()
file.close()
<!--ySrc = []
file = open("ex4y.dat")
line = file.readline()
while line:
    ySrc.append([npy.double(line.split()[0])])
    line = file.readline()
file.close()-->

# 取随机训练集和测试集
trainXSrc, trainYSrc, testXSrc, testYSrc, testYRst = [], [], [], [], []
xyIndex = list(range(len(xSrc)))
shuffle(xyIndex)
# 测试集
for ind in range(0, 16):
    testXSrc.append(xSrc[xyIndex[ind]])
    testYSrc.append(ySrc[xyIndex[ind]])
# 训练集
for ind in range(16, len(xyIndex)):
    trainXSrc.append(xSrc[xyIndex[ind]])
    trainYSrc.append(ySrc[xyIndex[ind]])

# 初始化参数
x = npy.mat(trainXSrc).T
y = npy.mat(trainYSrc)
trainSz = len(trainXSrc)
tx = npy.mat(testXSrc).T
ty = npy.mat(testYSrc)
testSz = len(testXSrc)
bSz = 5
b = npy.zeros((1, bSz))
w = npy.full((1, bSz), 0.5)
v = npy.full((bSz, 2), 0.5)
gamma = npy.full((1, bSz), 0.5)
theta = 0.5
alpha = 0.009

# 归一化
xMax = npy.max(x, axis=1)
xMin = npy.min(x, axis=1)
xnm = x.copy()
for nn in range(0, trainSz):
    for mm in range(0, 2):
        xnm[mm, nn] = ((xnm[mm, nn] - xMin[mm, 0]) / (xMax[mm, 0] - xMin[mm, 0]) - 0.5) * 10
txMax = npy.max(tx, axis=1)
txMin = npy.min(tx, axis=1)
tnm = tx.copy()
for nn in range(0, testSz):
    for mm in range(0, 2):
        tnm[mm, nn] = ((tnm[mm, nn] - txMin[mm, 0]) / (txMax[mm, 0] - txMin[mm, 0]) - 0.5) * 10

# 数据记录
epochRec, costRec = [], []

# 反向传播
for epo in range(0, 1000):
    # Cost Function
    cost = 0
    for r in range(0, trainSz):
        # 取训练集当前x、y
        xSample = xnm[:, r]
        ySample = y[r, 0]
        # b
        for h in range(0, bSz):
            b[0, h] = sigmoid((v[h, :] * xSample + gamma[0, h])[0, 0])
        # \hat{y}
        yEst = sigmoid((w * b.T)[0, 0] + theta)
        # Error of Output Layer
        errOut = (yEst - ySample) * yEst * (1 - yEst)
        # Error of Hidden Layer
        errHid = []
        for h in range(0, bSz):
            errHid.append(errOut * w[0, h] * b[0, h] * (1 - b[0, h]))
        # 梯度下降
        for h in range(0, bSz):
            w[0, h] = w[0, h] - alpha * errOut * b[0, h]
            v[h, 0] = v[h, 0] - alpha * errHid[h] * xSample[0, 0]
            v[h, 1] = v[h, 1] - alpha * errHid[h] * xSample[1, 0]
            gamma[0, h] = gamma[0, h] - alpha * errHid[h]
        theta = theta - alpha * errOut
        # 记录Cost Function值
        cost = cost + (yEst - ySample) * (yEst - ySample) / 2
    # 记录本轮Cost Function值，绘图用
    epochRec.append(epo)
    costRec.append(cost / trainSz)

# 测试
for r in range(0, testSz):
    txSample = tnm[:, r]
    tb = npy.zeros((1, bSz))
    for h in range(0, bSz):
        tb[0, h] = sigmoid((v[h, :] * txSample + gamma[0, h])[0, 0])
    testYRst.append(sigmoid((w * tb.T)[0, 0] + theta))

# 输出测试结果
for r in range(0, testSz):
    print("x0 = " + str(tx[0, r]) + ", x1 = " + str(tx[1, r]) + ", y = " + str(testYRst[r]))

# 绘图
ppl.figure(figsize=(13.5, 6.5))
ppl.subplot2grid((1, 5), (0, 0), colspan=2)
ppl.title("Cost function")
ppl.plot(epochRec, costRec,'c')

x10, x11, x20, x21 = [], [], [], []
for k in range(0, trainSz):
    if y[k, 0] == 0:
        x10.append(x[0, k])
        x20.append(x[1, k])
    else:
        x11.append(x[0, k])
        x21.append(x[1, k])
tx10corr, tx11corr, tx20corr, tx21corr, tx10wrong, tx11wrong, tx20wrong, tx21wrong = [], [], [], [], [], [], [], []
for k in range(0, testSz):
    if ty[k, 0] == 0:
        if testYRst[k] <= 0.5:
            tx10corr.append(tx[0, k])
            tx20corr.append(tx[1, k])
        else:
            tx10wrong.append(tx[0, k])
            tx20wrong.append(tx[1, k])
    else:
        if testYRst[k] > 0.5:
            tx11corr.append(tx[0, k])
            tx21corr.append(tx[1, k])
        else:
            tx11wrong.append(tx[0, k])
            tx21wrong.append(tx[1, k])
ppl.subplot2grid((1, 5), (0, 2), colspan=3)
ppl.title("Result")
ppl.plot(x10, x20, 'x', color='C7', label="0 (Training data)")
ppl.plot(x11, x21, 'o', color='C4', label="1 (Training data)")
ppl.plot(tx10corr, tx20corr, 'xg', label="0 (Tested 0, correct)")
ppl.plot(tx10wrong, tx20wrong, 'xr', label="0 (Tested 1, wrong)")
ppl.plot(tx11corr, tx21corr, 'og', label="1 (Tested 1, correct)")
ppl.plot(tx11wrong, tx21wrong, 'or', label="1 (Tested 0, wrong)")
ppl.legend(loc="best", framealpha=0.333)
ppl.tight_layout()
ppl.show()
